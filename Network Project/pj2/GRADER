                                     GRADER

Name of student running submit: Nick Helvig
Login of student running submit: cs61b-yl

Second team member's name:
Second team member's login:

Third team member's name (if any):
Third team member's login:

IMPORTANT:  Once you've submitted Project 2 once, the same team member should
submit always.  If a different teammate must submit, inform cs61b@cory.eecs of
all the details.  Include a complete list of team members, and let us know
which submission you want graded.

If you've submitted your project once, or even written a substantial amount of
code together, you may not change partners without the permission of the
instructor.
===============================================================================
Does your program compile without errors?


Have you tested your program on the machines in the Soda CS 61B lab?


Did you successfully implement game tree search?  Did you successfully
implement alpha-beta pruning?  Are there any limitations on it?  What is the
default number of search levels set by the one-parameter MachinePlayer
constructor?


Describe your board evaluation function in some detail.


Does your MachinePlayer use any special method of choosing the first few moves?


Is there anything else the graders should know to help them read your project?



Describe the classes, modules, and interfaces you designed before and while you
implemented the project.  Your description should include:
  -  A list of the classes your program uses.
  -  A list of each of the "modules" used in or by MachinePlayer, similar to
     the list in the "Teamwork" section of the README (but hopefully more
     detailed).
  -  For each module, list the class(es) the module is implemented in.
  -  For each module, say which of your team members implemented it.
  -  For each module, describe its interface--specifically, the prototype and
     behavior of each method that is available for external callers (outside
     the module) to call.  Don't include methods that are only meant to be
     called from within the module.

     For each method, provide (1) a method prototype and (2) a complete,
     unambiguous description of the behavior of the method/module.  This
     description should also appear before the method in your code's comments.

You will probably need to change some of your design decisions as you go; be
sure to modify this file to reflect these changes before you submit your
project.  Your design of classes and interfaces with be worth about 10% of your
grade.

  *2)  generating a list of all valid moves,
  *3)  finding the chips (of the same color) that form connections with a chip,
  *4)  determining whether a game board contains any networks for a given
       player (very difficult; put your smartest teammate on this),


We will use a class called GameBoard that will contain all the methods pertaining to the board itself, as well as
contain the gameboard information in an int [] array of 77. A 1 will represent a black piece in that position, a 2
will represent a white piece, and a 0 will represent no piece at all.  The gameboard is private to 
each player. A gameboard instance will be updated for each player as each move is made.



1.
Check Move Module:
/***Method checks whether a move passed in as a parameter is legal for the given player. 
Returns true if move is legal, false if not. Method will be in the GameBoard Class
*/
public boolean isValid (Move move, int player);


2.
Implemented by Nick
validMoves generates a list of all possible moves by going through each space of
the internal game board and checking whether or not that space is a valid space 
to play a piece. If it is, it is added to the Move[]. If it is not a valid move,
nothing happens. 
validMoves takes no parameters
returns an array of valid moves
protected Move[] validMoves() {
  
}



3.
Implemented by Nick
These would be in MachinePlayer.java
cChip functions are helper functions that find the closest chip of the same color
in the up, down, left, right, and diagonal spaces. 
@params color is the color of the chips you are looking for
        coordinate - location of the chip
@returns the coordinates of the closest chip of that color. if the closest chip is
         not of the same color, returns null

protected int[][] cChipsUp (int color, coordinate) {
  
}

protected int[][] cChipsDown (int color, coordinate) {
  
}

protected int[][] cChipsRight (int, color, coordinate) {
  
}

protected int[][] cChipsLeft (int color, coordinate) {
  
}

protected int[] cChipsDiagUpLeft (int color, coordinate) {
  
}

protected int[] cChipsDiagUpRight (int color, coordinate) {
  
}

protected int[] cChipsDiagDownLeft (int color, coordinate) {
  
}

protected int[] cChipsDiagDownRight (int color, coordinate) {
  
}

connectedChips finds all chips of the same color that are connected to the chip using the 
cChip functions and returns them as an array of chip coordinates.
@params  color - the color of the chip (black or white)
         coordinate - the location of the chip on the gameboard
@returns an array of all the connected chip positions

protected int[] connectedChips(int color, int coordinate) {
  
}



4. 

inGoal() checks to see if a chip is in the goal area for a certain player. This will be used
to check the start and end points of the network. Since the start and end points both need to
be in a goal area, inGoal() will make sure the connection is valid for the start and end points
@params color - the color of the player looking to see if his chip is in a goal
        coordinate - location of the chip
@returns true if the chip is in the goal
         false if the chip is not in the player's goal area
public boolean inGoal(int color, int location)


containsNetworks() evaluates a board and check's each chips list of connections to see if 
there is a Network of 6 or more chips. Uses an array to make sure that the same chip is not 
called more than once. Also keeps track of the direction of the chip so that two chips in a
line are not allowed to be in the same network. Makes sure the beginning and ending chips are
in the goal areas using inGoal().
@params color - the color of the player searching for a network
@returns true if there is a Network for the given player
         false if there are no valid Networks

public boolean containsNetwork (int color) {
  
}


5.
Evaluation Module:
/***
This method will be in the GameBoard class, and given a Gameboard "this" and which player it is evaluating for (1
if the current player is black, 2 if the current player is white),
it will return a double between -1.0 and 1.0 that estimates the strength of the board. -1 means the opponent has 
already won for this board, and 1 means the player has already won for this board. It will call the method containsNetwork in 
the determine network module in order to find out if a player has a network or not. It will also use repeated calls
to that method containsNetwork so that it can give an accurate assessment of which player is closest to winning, with high 
positives correlating to high likelihood of the current player winning, and low negatives correlating to low likelihood of 
current player winning. 
*/
public double evaluateBoard (int player);



6.
MiniMax module:
/***
This method will be in the GameBoard class, and given a GameBoard "this" and which player it is evaluating for
(1 if the player is black, 2 if the player is white), it will return the best possible move in the current circumstance
within the chosen search depth. The method will utilize many calls to method evaluateBoard in the Evaluation module
to pick the best possible move. The method will also need to call the method containsNetwork in the network identifier module.
*/

public Move returnBest (int player, int searchdepth)
public Move returnBest (int player, int searchdepth, int alpha, int beta);